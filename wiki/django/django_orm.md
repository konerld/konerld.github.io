
    from .models import Post

Получить все записи модели Post
 
    Post.objects.all()

Получить запись модели Post, у которой:
- значение поля id равно 1. 

    Post.objects.get(id=1)

Поскольку поле id — это первичный ключ, а Django автоматически создаёт у модели свойство pk, то альтернативная запись этого же запроса будет такой:

    Post.objects.get(pk=1)

Запрос вернёт объекты, у которых значение года в поле pub_date равно 1854. 

    Post.objects.filter(pub_date__year=1854)

Обратите внимание на синтаксис фильтрации: двойное нижнее подчёркивание между названиями поля и фильтра. Подробнее о функции filter() — в [документации](https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.filter)


Пример фильтра по текстовому полю, он вернёт записи, начинающиеся с указанной в фильтре строки.

    Post.objects.filter(text__startswith="Писать не хочется")


## Фильтры

### date

    {{ pub_date|date:"j.m.Y" }} {# выведет 2.02.2019 #} 
    {{ pub_date|date:"j F Y" }} {# выведет 2 февраля 2019 #}
    {{ pub_date|date:"d.m.y" }} {# выведет 02.02.19 #}
    {{ pub_date|date:"d M Y" }} {# выведет 02 фев 2019 #}

### linebreaksbr

Он заменяет символы перевода строки \n на HTML-теги <br>.

### Комментарии

Django-шаблоны поддерживают комментарии — строки, которые игнорируются при интерпретации кода. Однострочные комментарии записываются между символами {# и #}, многострочные — между конструкциями {% comment %} и {% endcomment %}


## Теги

### Одиночные

    {% include "footer.html" %}

### Парные

    {% block %}
        тело тега
    {% endblock %}

### Примеры

    {% if variable %} ... {% endif %}. 

К параметрам можно применять фильтры:
    
    {% if messages|length >= 100 %}

### Тэг block

Содержимое тега block может быть переопределено из другого шаблона. Если значение тега не переопределено, на страницу будет выведено значение, которое предустановлено в шаблоне (это значение может быть и пустым).

После названия тега block указывается его идентификатор:

    {% block title %}, {% block sidebar %} или {% block content %}

Идентификатор разработчик придумывает сам.

* Блок title в HTML-теге <title>: здесь указано название страницы, отображаемое в заголовке окна браузера.
* Блок sidebar — навигация по сайту, боковое меню.
* Блок content — основной блок страницы, её содержание. Оно передаётся из других шаблонов. Если этот блок не переопределён, на страницу будет выведено сообщение «Контент не подвезли :(»



### Тег extends

диночный тег extends сообщает системе, в каком шаблоне нужно переопределить блоки, описанные следом за этим тегом.

Например, если система вызывает какой-то шаблон и видит в нём тег extends "index.html", то в шаблоне indeх.html будут заменены все блоки, которые в вызванном шаблоне перечислены по именам после тега {% extends "index.html" 

Создадим шаблон list.html, который переопределит блоки title, sidebar и content в шаблоне base.html.

    {% extends "base.html" %}

    {% block title %}Список сообщений{% endblock %}

    {% block sidebar %}
            <ul>
                <li><a href="/">Главная</a></li>
                <li><a href="/about/">О сайте</a></li>
                <li><a href="/list/" class="active">Сообщения</a></li>
            </ul>
            {% endblock %}

    {% block content %}
    {% for msg in messages %}
        <h2>{{ msg.title }}, от {{ msg.from }}</h2>
        <p>{{ msg.body }}</p>
    {% endfor %}
    {% endblock %}

Теперь из view-функции можно вызвать шаблон list.html, передать в него список messages с объектами сообщений (со свойствами title, from, body) — и сервер вернёт HTML-страницу с кодом из шаблона base.html, но с контентом, сгенерированным в файле list.html. То есть будет установлен <title> «Список сообщений», в сайдбаре будет подсвечен пункт меню «Сообщения», а в блок content — выведен список самих сообщений.

Пользователю будет возвращена страница list.html, в которой весь код будет из base.html, а содержимое блоков — из list.html.


### Тег include

Этот тег по своей задаче — антипод тега extend.

Он включает в код шаблона содержимое другого шаблона. Вот простенький файл index.html:

<!DOCTYPE html>
<html>
<head>
    <title>The Last Social Media You'll Ever Need | Yatube</title>
    <link rel="stylesheet" href="style.css">
</head>

    <body>
        {% include "header.html" %}
        <nav id="sidebar">        
            <ul>
                <li><a href="/">Главная</a></li>
                <li><a href="/about/">О сайте</a></li>
                <li><a href="/list/">Сообщения</a></li>
            </ul>        
        </nav>

        <div id="content">
            Контент страницы
        </div>
        {% include "footer.html" %}
    </body>
    </html>

В той же директории, где сохранён index.html, лежат ещё два файла:
файл header.html

    <div id="top-of-site">
    {# здесь описана шапка сайта, она повторяется на всех страницах проекта #}
        <img src="images/logo.jpg" alt="Yatube" />
        <div id="site-name">Yatube</div>
    </div>

файл footer.html

    <div id="bottom-of-site">
    {# здесь описан подвал сайта, он одинаковый на всех страницах проекта #}
        <img src="images/logo.jpg" alt="Yatube" /> Yatube
        <div id="copyright">© Все права принадлежат всем</div>
    </div>

В результате обработки шаблона index.html на место тегов {% include "header.html" %} и {% include "footer.html" %} будет вставлен код из соответствующих файлов.

В тег include можно передать дополнительные параметры. Например, для вывода контактов можно создать шаблон card.html:

    <div class="card">
        {{ name }} <br>
        <a href="mailto:{{ email }}">Отправить сообщение</a>
    </div>

При включении в шаблон user.html передаём в код шаблона card.html нужные данные:

    <html>
    <head>
        <title>Иван Васильевич | Yatube</title>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>
        {% include "header.html" %}
        <nav id="sidebar">        
            <ul>
                <li><a href="/">Главная</a></li>
                <li><a href="/about/">О сайте</a></li>
                <li><a href="/list/">Сообщения</a></li>
            </ul>        
        </nav>
        
        <div id="content">
            {% include "card.html" with name="Иван Васильевич" email="iv@example.com" %}
            {# а можно сделать иначе: передать значения переменных #}
            {% include "card.html" with name=user.name email=user.mail %}
        </div>
        {% include "footer.html" %}
    </body>
    </html>

### Тег ветвления

    {% if news %}
        У вас {{ news|length }} обновлений новостей
    {% elif is_holiday %}
        Новостей нет, сегодня же праздник!
    {% else %}
        Сегодня нет новостей.
    {% endif %}

В условиях {% if %} работают операторы сравнения <, >, <=, >=, !=, ==, логические операторы or, and, not, операторы тождественности is и вхождения in, круглые скобки и стандартные правила приоритета операций.

В условиях можно применять и фильтры:

    {% if news|length >= 100 %}
    Сегодня больше сотни новостей! Что случилось?
    {% endif %}

### Циклы

Тег for выполняет определённый код для каждого элемента списка, переданного в цикл.

Допустим, из view-функции в шаблон передан словарь dict_data, в нём есть элемент items, в этом элементе содержится словарь, всё содержимое которого вместе с ключами нужно вывести на страницу:

    {% for key, value in dict_data.items %}
        Ключ '{{ key }}': Значение '{{ value }}'
    {% endfor %}

Помимо обычных переменных в циклах создаются и вспомогательные, они доступны в специальной переменной forloop:

* forloop.counter — текущий счетчик выполнений цикла, начинается с 1;
* forloop.counter0 — текущий счетчик выполнения цикла, начинается с 0;
* forloop.revcounter — сколько итераций осталось до конца цикла, начинается с 1;
* forloop.revcounter0 — сколько итераций осталось до конца цикла, начинается с 0;
* forloop.first — вернёт True на первой итерации цикла, в остальных случаях вернёт False;
* forloop.last — вернёт True на последней итерации цикла, в остальных случаях вернёт False;
* forloop.parentloop — если цикл был запущен внутри другого цикла, то в этой переменной находится переменная forloop родительского цикла.

Необязательный тег {% empty %}, вложенный в for, сработает, если переданный в цикл список пуст:

    <ul>
    {% for news in news_list %}
        <li>{{ news.title }}</li>
    {% empty %}
        <li>Список новостей пуст.</li>
    {% endfor %}
    </ul>

То же самое можно написать и без {% empty %}, но получится громоздко:

    <ul>
        {% if news_list %}
            {% for news in news_list %}
                <li>{{ news.title }}</li>
            {% endfor %}
        {% else %}
            <li>Список новостей пуст.</li>
        {% endif %}
    </ul>

Вложенный в for тег {% ifchanged %} запоминает значение переданных параметров или своего тела между запусками цикла, — и если они не поменялись, скрывает его.

В этом листинге HTML-заголовок <h2> с названием месяца будет выводиться на страницу только если в предыдущей итерации цикла название месяца было другим.

    <h1>Архив новостей за {{ year }}</h1>

    {% for news in news_items %}
        {% ifchanged %}
            <h2>{{ news.pub_date|date:"F" }}</h2>
        {% endifchanged %}

        <h3>{{ news.pub_date|date:"d.m.Y" }} | {{ news.title}}</h3>
    {% endfor %}

В результате работы цикла получится примерно такой HTML-код:

    <h1>Архив новостей за 2019</h1>
    <h2>Январь</h2>
    <h3>1.01.2019 | С Новым Годом!</h3>
    <h3>2.01.2019 | С Днём научной фантастики!</h3>
    <h3>3.01.2019 | С Днём рождения соломинки для коктейлей!</h3>
    <h2>Февраль</h2>
    <h3>1.02.2019 | С Днём работника лифтового хозяйства!</h3>
    <h3>2.02.2019 | С Днём сурка!</h3>
    <h3>2.02.2019 | С Днём сурка!</h3>
    <h3>2.02.2019 | С Днём сурка!</h3>

Без тега {% ifchanged %} получилось бы хуже:

    <h1>Архив новостей за 2019</h1>
    <h2>Январь</h2>
    <h3>1.01.2019 | С Новым Годом!</h3>
    <h2>Январь</h2>
    <h3>2.01.2019 | С Днём научной фантастики!</h3>
    <h2>Январь</h2>
    <h3>3.01.2019 | С Днём рождения соломинки для коктейлей!</h3>
    <h2>Февраль</h2>
    <h3>1.02.2019 | С Днём работника лифтового хозяйства!</h3>
    <h2>Февраль</h2>
    <h3>2.02.2019 | С Днём сурка!</h3>
    <h2>Февраль</h2>
    <h3>2.02.2019 | С Днём сурка!</h3>
    <h2>Февраль</h2>
    <h3>2.02.2019 | С Днём сурка!</h3>


### Тег url

Тег {% url %} генерирует ссылки на страницы проекта. Из кода шаблона можно обратиться к именам адресов, зарегистрированных в списке urlpatterns в файле urls.py, и передать параметры, если они требуются:

    urlpatterns = [
        path('', views.index, name='index'),
        path('/detail/<int:pk>/', views.details, name='detail'),
        ...
    ]

Первый параметр тега url — это name пути из файла urls.py:

    <a href="{% url 'index' %}">Главная</a>

После name при необходимости передаются значения переменных, которые принимает path() в urls.py

    urlpatterns = [
        path('/detail/<int:pk>/', views.details, name='detail'),
        path('/<str:username>/<int:id>/', views.article, name='article'),
    ]

    {# передаём один параметр #}
    <a href="{% url 'detail' 1 %}">Подробнее об объекте 1</a> {# получится ссылка detail/1 #}
    <a href="{% url 'detail' pk=1 %}">Подробнее об объекте 1</a>
    <a href="{% url 'detail' pk=object.id %}">Подробнее об объекте {{ object.id }}</a>

    {# передаём несколько параметров #}
    <a href="{% url 'article' 'anton' 16 %}">Статья с ID=16, автор: anton</a>
    <a href="{% url 'article' username='anton' id=16 %}">Статья с ID=16, автор: anton</a>
    <a href="{% url 'article' username=article.username id=article.id %}">Статья с ID={{ article.id }}, автор: {{ article.username }}</a>

